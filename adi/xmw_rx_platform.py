# Copyright (C) 2023 Analog Devices, Inc.
#
# SPDX short identifier: ADIBSD
# Copyright (C) 2023 Analog Devices, Inc.
#
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without modification,
# are permitted provided that the following conditions are met:
#     - Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     - Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in
#       the documentation and/or other materials provided with the
#       distribution.
#     - Neither the name of Analog Devices, Inc. nor the names of its
#       contributors may be used to endorse or promote products derived
#       from this software without specific prior written permission.
#     - The use of this software may or may not infringe the patent rights
#       of one or more patent holders.  This license does not release you
#       from the requirement that you obtain separate licenses from these
#       patent holders to use this software.
#     - Use of the software either in source or binary form, must be run
#       on or directly connected to an Analog Devices Inc. component.
#
# THIS SOFTWARE IS PROVIDED BY ANALOG DEVICES "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
# INCLUDING, BUT NOT LIMITED TO, NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A
# PARTICULAR PURPOSE ARE DISCLAIMED.
#
# IN NO EVENT SHALL ANALOG DEVICES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, INTELLECTUAL PROPERTY
# RIGHTS, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
# BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
# THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

from adi.ad9081 import ad9081
from adi.adrf5020 import adrf5020
from adi.adrf5730 import adrf5730
from adi.adrf5740 import adrf5740
from adi.context_manager import context_manager


class xmw_rx_platform(ad9081):
    """2-24 GHz XMW RX Platform
    parameters:
    uri: type=string
        Optional parameter for the URI of IIO context with XMW RX Platform.
    """

    _device_name = ""

    def __init__(self, uri="ip:analog.local"):

        context_manager.__init__(self, uri, self._device_name)

        # Find and initialize all devices in the XMW RX Platform
        self._rx_clock_chip = self._ctx.find_device("hmc7044")
        self._rx_image_bpf = self._ctx.find_device("admv8818_img_filter")
        self._rx_preselector_bpf = self._ctx.find_device("admv8818_preselector")
        self._rx_fixed_pll = self._ctx.find_device("adf4371_fixed_PLL")
        self._rx_tunable_pll = self._ctx.find_device("adf4371_tunable_PLL")

        self._rx_input_switch = adrf5020(
            uri="ip:analog.local", dev_name="adrf5020_control_sw_1"
        )
        self._rx_if_switch = adrf5020(
            uri="ip:analog.local", dev_name="adrf5020_control_sw_3"
        )
        self._rx_input_dsa = adrf5740(
            uri="ip:analog.local", dev_name="adrf5740_control"
        )
        self._rx_if_dsa = adrf5730(uri="ip:analog.local", dev_name="adrf5730_control")

        # Default values for GPIO controlled Switch
        self._input_mode_switch = 1
        self._input_freq_range = 1
        self._input_freq_MHz = 4500

        # Default values for GPIO controlled Digital Signal Attenuators at Input stage and
        # Intermediate Frequency stage
        self._if_dsa_atten = 0
        self._input_dsa_atten = 0

        # Default values for preselector and Image Band Pass Filters
        self._image_bpf_center_freq = 4500
        self._image_bpf_bandwidth = 1000
        self._image_bpf_high_pass_freq = 4000
        self._image_bpf_low_pass_freq = 5000
        self._preselector_bpf_center_freq = 4500
        self._preselector_bpf_bandwidth = 1000
        self._preselector_bpf_high_pass_freq = 4000
        self._preselector_bpf_low_pass_freq = 5000

        # Default values for Fixed and Tunable PLLs
        self._fixed_pll_freq_MHz = 18000
        self._tunable_pll_freq_MHz = 16000

        # PLL output is from RF32x but this script is setting/getting frequency on RF8x (factor of 4)
        # Also, the linux driver for the ADF4371 PLL requires frequency to be in Hz while this script
        # takes frequency in MHz (factor of 1000000)
        # Net conversion factor is 1000000/4 = 250000
        self._channel_conv_factor = 250000

        # Default input mode (through Low Noise Amplifier)
        self._input_mode = 0

        # Default value for Intermediate Frequency to be generated by RX Platform
        self._if_freq_MHz = 4500

    @property
    def input_mode(self):
        """input mode: Get/Set the mode of operation for the input stage.
        Valid options are:
        0: Default LNA
        1: Tunable Pre-Selector
        """
        return self._input_mode

    @input_mode.setter
    def input_mode(self, value):
        self._input_mode = value
        if value == 0:
            print("Setting Input Mode to 0 (Default LNA)!")
            self.input_mode_switch = 1
        elif value == 1:
            print("Setting Input Mode to 1 (Pre-Selector Filter)!")
            self.input_mode_switch = 0
            # Ensure center frequency of Pre-Selector band pass filter is set to correct RF input frequency
            if self._preselector_bpf_center_freq != self._input_freq_MHz:
                self.preselector_bpf_freq_MHz = self._input_freq_MHz
        else:
            print("Setting Input Mode to 0 (Default LNA)!")
            self.input_mode_switch = 1

    @property
    def input_freq_MHz(self):
        """input_freq_MHz: Get/Set the desired input frequency in order to select
        the appropriate RF path.
        Valid options are 2-24 GHz with 0.5 GHz step size.
        """
        return self._input_freq_MHz

    @input_freq_MHz.setter
    def input_freq_MHz(self, value):
        print(
            f"Setting IF switch to select the appropriate path for an RF input of {value} MHz."
        )
        self._input_freq_MHz = value
        if self._input_freq_MHz <= 7000:
            self.input_freq_range = 1
            self.tunable_pll_freq_MHz = (
                self._fixed_pll_freq_MHz - self._input_freq_MHz + self._if_freq_MHz
            )
        elif self._input_freq_MHz > 7000:
            self.input_freq_range = 0
            self.tunable_pll_freq_MHz = self._input_freq_MHz + self._if_freq_MHz
        else:
            self.input_freq_range = 1
            self.tunable_pll_freq_MHz = (
                self._fixed_pll_freq_MHz - self._input_freq_MHz + self._if_freq_MHz
            )
        # Set center frequency of Pre-Selector Band Pass Filter to desired RF input frequency if
        # input mode 1 is selected
        if self._input_mode == 1:
            self.preselector_bpf_freq_MHz = value
        # Set center frequency of Image Band Pass Filter to desired RF input frequency
        self.image_bpf_freq_MHz = value

    @property
    def input_mode_switch(self):
        """ input_mode_switch: Get/Set input mode switch value to control input mode.
        Valid options are through Bypass LNA ('1') or through Preselector Filter ('0').
        """
        self._input_mode_switch = self._rx_input_switch.control_signal_value
        if self._input_mode_switch == 1:
            print("Input path is through the bypass LNA.")
        elif self._input_mode_switch == 0:
            print("Input path is through the preselector filter.")
        return self._input_mode_switch

    @input_mode_switch.setter
    def input_mode_switch(self, value):
        if value == 1:
            print("Selecting input path through the bypass LNA.")
            self._rx_input_switch.control_signal_value = value
        elif value == 0:
            print("Selecting input path through the preselector filter.")
            self._rx_input_switch.control_signal_value = value
        else:
            print(
                "Please select a valid option for input mode switch (1 through Bypass LNA or 0 through Preselector Filter)"
            )

    @property
    def input_freq_range(self):
        """ input_freq_range: Get/Set input frequency range to control IF switches.
        Valid options are:
        7.1-24 GHz ('0') or 2-7 GHz ('1')
        """
        self._input_freq_range = self._rx_if_switch.control_signal_value
        if self._input_freq_range == 0:
            print("Input frequency range is 7.1-24 GHz.")
        elif self._input_freq_range == 1:
            print("Input frequency range is 2-7 GHz.")
        return self._input_freq_range

    @input_freq_range.setter
    def input_freq_range(self, value):
        if value == 0:
            print("Selecting input frequency range of 7.1-24 GHz.")
            self._rx_if_switch.control_signal_value = value
        elif value == 1:
            print("Selecting input frequency range of 2-7 GHz.")
            self._rx_if_switch.control_signal_value = value
        else:
            print(
                "Please select a valid option for input frequency range (0 for 7.1-24 GHz or 1 for 2-7 GHz)"
            )

    @property
    def input_attenuation_dB(self):
        """ input_attenuation_dB: Get/Set attenuation value in dB for input stage.
        Valid options are 0-22 dB in steps of 2.
        """
        self._input_dsa_atten = self._rx_input_dsa.GPIO_attenuation
        return self._input_dsa_atten

    @input_attenuation_dB.setter
    def input_attenuation_dB(self, value):
        print(f"Setting attenuation of Input stage to {value} dB.")
        self._rx_input_dsa.GPIO_attenuation = value

    @property
    def if_attenuation_decimal(self):
        """ if_attenuation_decimal: Get/Set Attenuation Decimal value for Intermediate Frequency stage.
        Valid options are 0-63, corresponding to 0-31.5 dB.
        """
        self._if_dsa_atten = self._rx_if_dsa.GPIO_attenuation
        return self._if_dsa_atten

    @if_attenuation_decimal.setter
    def if_attenuation_decimal(self, value):
        print(
            f"Setting Attenuation Decimal of Intermediate Frequency stage to {value}."
        )
        self._rx_if_dsa.GPIO_attenuation = value

    @property
    def preselector_bpf_freq_MHz(self):
        """ preselector_bpf_freq_MHz: Get/Set the center frequency for the preselector Band Pass Filter
        with a fixed bandwidth of 1000 MHz.
        """
        self._preselector_bpf_center_freq = self._get_iio_attr(
            "altvoltage0",
            "filter_band_pass_center_frequency",
            True,
            self._rx_preselector_bpf,
        )
        print(
            f"Center frequency for preselector Band Pass Filter is {self._preselector_bpf_center_freq} MHz."
        )
        return self._preselector_bpf_center_freq

    @preselector_bpf_freq_MHz.setter
    def preselector_bpf_freq_MHz(self, value):
        print(
            f"Setting Center frequency of preselector Band Pass Filter to {value} MHz with a bandwidth of {self._preselector_bpf_bandwidth} MHz."
        )
        self._preselector_bpf_center_freq = value
        self._preselector_bpf_high_pass_freq = value - (
            self._preselector_bpf_bandwidth / 2
        )
        self._preselector_bpf_low_pass_freq = value + (
            self._preselector_bpf_bandwidth / 2
        )
        self._set_iio_attr(
            "altvoltage0",
            "filter_band_pass_center_frequency",
            True,
            self._preselector_bpf_center_freq,
            self._rx_preselector_bpf,
        )
        self._set_iio_attr(
            "altvoltage0",
            "filter_band_pass_bandwidth_3db_frequency",
            True,
            self._preselector_bpf_bandwidth,
            self._rx_preselector_bpf,
        )
        self._set_iio_attr(
            "altvoltage0",
            "filter_high_pass_3db_frequency",
            True,
            self._preselector_bpf_high_pass_freq,
            self._rx_preselector_bpf,
        )
        self._set_iio_attr(
            "altvoltage0",
            "filter_low_pass_3db_frequency",
            True,
            self._preselector_bpf_low_pass_freq,
            self._rx_preselector_bpf,
        )

    @property
    def image_bpf_freq_MHz(self):
        """ image_bpf_freq_MHz: Get/Set the center frequency for the image Band Pass Filter
        with a fixed bandwidth of 1000 MHz.
        """
        self._image_bpf_center_freq = self._get_iio_attr(
            "altvoltage0", "filter_band_pass_center_frequency", True, self._rx_image_bpf
        )
        print(
            f"Center frequency for preselector Band Pass Filter is {self._image_bpf_center_freq} MHz."
        )
        return self._image_bpf_center_freq

    @image_bpf_freq_MHz.setter
    def image_bpf_freq_MHz(self, value):
        print(
            f"Setting Center frequency of image Band Pass Filter to {value} MHz with a bandwidth of {self._image_bpf_bandwidth} MHz."
        )
        self._image_bpf_center_freq = value
        self._image_bpf_high_pass_freq = value - (self._image_bpf_bandwidth / 2)
        self._image_bpf_low_pass_freq = value + (self._image_bpf_bandwidth / 2)
        self._set_iio_attr(
            "altvoltage0",
            "filter_band_pass_center_frequency",
            True,
            self._image_bpf_center_freq,
            self._rx_image_bpf,
        )
        self._set_iio_attr(
            "altvoltage0",
            "filter_band_pass_bandwidth_3db_frequency",
            True,
            self._image_bpf_bandwidth,
            self._rx_image_bpf,
        )
        self._set_iio_attr(
            "altvoltage0",
            "filter_high_pass_3db_frequency",
            True,
            self._image_bpf_high_pass_freq,
            self._rx_image_bpf,
        )
        self._set_iio_attr(
            "altvoltage0",
            "filter_low_pass_3db_frequency",
            True,
            self._image_bpf_low_pass_freq,
            self._rx_image_bpf,
        )

    @property
    def fixed_pll_freq_MHz(self):
        """ fixed_pll_freq_MHz: Get/Set the LO frequency generated by the fixed PLL."""
        self._fixed_pll_freq_MHz = (
            self._get_iio_attr("altvoltage0", "frequency", True, self._rx_fixed_pll)
        ) / self._channel_conv_factor
        print(f"LO frequency generated by Fixed PLL is {self._fixed_pll_freq_MHz} MHz.")
        return self._fixed_pll_freq_MHz

    @fixed_pll_freq_MHz.setter
    def fixed_pll_freq_MHz(self, value):
        print(f"Setting LO frequency generated by Fixed PLL to {value} MHz.")
        self._fixed_pll_freq_MHz = value * self._channel_conv_factor
        self._set_iio_attr(
            "altvoltage0",
            "frequency",
            True,
            self._fixed_pll_freq_MHz,
            self._rx_fixed_pll,
        )

    @property
    def tunable_pll_freq_MHz(self):
        """ tunable_pll_freq_MHz: Get/Set the LO frequency generated by the Tunable PLL."""
        self._tunable_pll_freq_MHz = (
            self._get_iio_attr("altvoltage0", "frequency", True, self._rx_tunable_pll)
        ) / self._channel_conv_factor
        print(
            f"LO frequency generated by Tunable PLL is {self._tunable_pll_freq_MHz} MHz."
        )
        return self._tunable_pll_freq_MHz

    @tunable_pll_freq_MHz.setter
    def tunable_pll_freq_MHz(self, value):
        print(f"Setting LO frequency generated by Tunable PLL to {value} MHz.")
        self._tunable_pll_freq_MHz = value * self._channel_conv_factor
        self._set_iio_attr(
            "altvoltage0",
            "frequency",
            True,
            self._tunable_pll_freq_MHz,
            self._rx_tunable_pll,
        )
